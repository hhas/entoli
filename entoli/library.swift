//
//  library.swift
//  entoli-run
//
//  Standard library
//  
//


// TO DO: how to package this crap? (e.g. swift stdlib defines Process as enum with static properties, but frankly that smells)

// one thing to remember is that primitive funcs should be pure Swift logic - no glue code - so that compiler can emit Swift code just by chaining primitive funcs together when there is sufficient entoli type info to eliminate intermediate Value boxing and unboxing (Q. what about inlining and/or ability to output source code directly?)

// TO DO: how/where to merge proc's returnType with caller's required type (Q. how? making this a generic func screws up class wrapper; making return type Any might avoid the problem); might be best if Coercion.union() always returns a NativeCoercion, and have that return an opaque value that is easily unwrapped, e.g. if caller wants Array<Int> and func's return type is ListType(itemType:IntegerType()), we don't want to wrap and unwrap every single item

// note: one issue with library-defined operators is that scripts won't parse/format correctly unless those libraries are present (or at least their operator definitions, which should exist as part of the documentation; suggesting the problem might be ameliorated by library repository making that documentation available even when [e.g. commercial] libraries aren't; another option, of course, is to reduce scripts to command-only format for exchange, although that isn't good for readability; yet another option is to copy custom operator definitions to script's header for reference, thereby at least localizing the ugliness)

//  TO DO: need to think about how libraries might define their own Value subclasses (e.g. as opaque wrappers for external objects, e.g. GUI classes) and corresponding commands, although where possible libraries should stick to built-in types, using records to describe complex data structures (e.g. it might be that a record's values could be read-only to prevent modification outside of its associated commands; private state could similarly be hidden in annotations, although it should always be reconstructable since annotations are not guaranteed to persist, and two records that look identical should be interchangeable, regardless of how they were created; otherwise use an opaque value, which makes no such promises)


//**********************************************************************
// the following tuple describes the entoli interface for a single primitive procedure, and needs to be recognizable and parseable to glue code generator
//
// (note: this tuple doesn't have a standard type as parameter tuple does not have fixed length/type, and a variable-length structure such as Array doesn't provide the static type info required by evalRecordField() generic, which needs to know the *exact* Coercion class in order to determine its correct return type)

private let proc_add = (name: Name("+"), // note: glue generator should be smart enough to wrap String-based proc/param names as Name
                        parameter: (lhs: (gLeftOperandName, ScalarCoercion()), rhs: (gRightOperandName, ScalarCoercion())),
                        result: ScalarCoercion(),
                        function: (+) as ScalarArithmeticFunc) // TO DO: need a `scope` enum of .None|.Parent|.Body|.Closure

// TO DO: what about describing errors [as part of result]?
// TO DO: proc metadata (documentation, categorization, etc)
// TO DO: operator definition (optional)
// TO DO: should there be standard for declaring aliases?


//**********************************************************************
// the following code should be autogenerated from above

private func call_add(var arguments: [Value], commandScope: Scope, procedureScope: Scope, returnType: Coercion) throws -> Value { // TO DO: returnType is problematic, as its exact class is variable and only determined at call-time, and doesn't have sufficient type info for Coercion.intersect() to be used below; for now, it's ignored entirely, but this needs to be FIXED soon as it has major impact on interpreter and library glue design
    let arg1 = try evalRecordField(&arguments, fieldStructure: proc_add.parameter.0, commandScope: commandScope)
    let arg2 = try evalRecordField(&arguments, fieldStructure: proc_add.parameter.1, commandScope: commandScope)
    if arguments.count > 0 { throw BadArgument(description: "Too many arguments(s): \(arguments)") } // TO DO: need to finalize error's API
    let rawResult = try proc_add.function(arg1, arg2)
    return try proc_add.result.wrap(rawResult, env: procedureScope) // TO DO: problem: how to intersect proc's returnType with with caller's requested returnType? (there is an implicit constraint here in that returnType's CoercionProtocol.SwiftType should always be Value)
}


func loadLibrary(env: Scope) throws {
    try env.store(PrimitiveProcedure(name: proc_add.name,
                                     parameterType: RecordSignature(FieldSignature(proc_add.parameter.0.0, proc_add.parameter.0.1),
                                                                    FieldSignature(proc_add.parameter.1.0, proc_add.parameter.1.1)),
                                     returnType: proc_add.result, function: call_add))
}
